import { Octokit } from '@octokit/rest';

/**
 * Create an Octokit instance with the server PAT (for template operations)
 */
export function createOctokit() {
  const token = process.env.GH_PAT;
  if (!token) {
    throw new Error('GH_PAT environment variable is not set');
  }
  return new Octokit({ auth: token });
}

/**
 * Create an Octokit instance with a user's GitHub token
 */
export function octokitWithToken(token: string) {
  return new Octokit({ auth: token });
}

/**
 * Create a new repository from a template
 */
export async function createFromTemplate(
  owner: string,
  name: string,
  isPrivate = true,
  templateOwner = 'vibeweb-app',
  templateRepo = 'nextjs-vibe-template'
) {
  const octo = createOctokit();
  
  try {
    const response = await octo.rest.repos.createUsingTemplate({
      template_owner: templateOwner,
      template_repo: templateRepo,
      owner,
      name,
      private: isPrivate,
      include_all_branches: false,
    });
    
    return response.data;
  } catch (error: any) {
    if (error.status === 404) {
      throw new Error(`Template repository ${templateOwner}/${templateRepo} not found`);
    }
    throw error;
  }
}

/**
 * Push multiple files to a GitHub repository
 * This will replace ALL files in the repository with the provided files
 */
export async function pushFiles(
  userToken: string,
  repo: { owner: string; name: string },
  branch: string,
  files: Record<string, string>,
  message: string,
) {
  const octo = octokitWithToken(userToken);

  try {
    console.log(`Pushing files to ${repo.owner}/${repo.name} on branch ${branch}`);
    
    // 1. Get the latest commit SHA
    const { data: ref } = await octo.git.getRef({
      owner: repo.owner,
      repo: repo.name,
      ref: `heads/${branch}`,
    });
    const baseSha = ref.object.sha;

    // 2. Get the base tree
    const { data: baseCommit } = await octo.git.getCommit({
      owner: repo.owner,
      repo: repo.name,
      commit_sha: baseSha,
    });
    const baseTreeSha = baseCommit.tree.sha;

    // 3. Create blobs for every file
    const blobs = await Promise.all(
      Object.entries(files).map(async ([path, content]) => {
        const { data } = await octo.git.createBlob({
          owner: repo.owner,
          repo: repo.name,
          content,
          encoding: 'utf-8',
        });
        return { 
          path, 
          sha: data.sha, 
          mode: '100644' as const, 
          type: 'blob' as const 
        };
      }),
    );

    // 4. Create a new tree
    // Don't use base_tree to replace all files instead of merging
    const { data: tree } = await octo.git.createTree({
      owner: repo.owner,
      repo: repo.name,
      tree: blobs,
    });

    // 5. Create a new commit
    const { data: commit } = await octo.git.createCommit({
      owner: repo.owner,
      repo: repo.name,
      message,
      tree: tree.sha,
      parents: [baseSha],
    });

    // 6. Update the reference
    await octo.git.updateRef({
      owner: repo.owner,
      repo: repo.name,
      ref: `heads/${branch}`,
      sha: commit.sha,
    });

    return { commit: commit.sha, tree: tree.sha };
  } catch (error: any) {
    console.error('Error pushing files to GitHub:', error);
    throw new Error(`Failed to push files: ${error.message}`);
  }
}

/**
 * Create a pull request
 */
export async function createPullRequest(
  userToken: string,
  repo: { owner: string; name: string },
  title: string,
  head: string,
  base: string = 'main',
  body?: string,
) {
  const octo = octokitWithToken(userToken);
  
  try {
    const { data } = await octo.pulls.create({
      ...repo,
      title,
      head,
      base,
      body: body || `Generated by Vibe Web AI\n\n${title}`,
    });
    
    return data;
  } catch (error: any) {
    if (error.status === 422) {
      // PR might already exist
      const { data: existingPRs } = await octo.pulls.list({
        ...repo,
        head: `${repo.owner}:${head}`,
        base,
      });
      
      if (existingPRs.length > 0) {
        return existingPRs[0];
      }
    }
    throw error;
  }
}

/**
 * Create a new branch
 */
export async function createBranch(
  userToken: string,
  repo: { owner: string; name: string },
  branchName: string,
  baseBranch: string = 'main',
) {
  const octo = octokitWithToken(userToken);
  
  try {
    // Get the SHA of the base branch
    const { data: ref } = await octo.git.getRef({
      ...repo,
      ref: `heads/${baseBranch}`,
    });
    
    // Create the new branch
    await octo.git.createRef({
      ...repo,
      ref: `refs/heads/${branchName}`,
      sha: ref.object.sha,
    });
    
    return { branch: branchName, sha: ref.object.sha };
  } catch (error: any) {
    if (error.status === 422) {
      // Branch might already exist
      return { branch: branchName, sha: null };
    }
    throw error;
  }
}

/**
 * Check if a repository exists
 */
export async function repoExists(
  userToken: string,
  owner: string,
  repo: string,
): Promise<boolean> {
  const octo = octokitWithToken(userToken);
  
  try {
    await octo.repos.get({ owner, repo });
    return true;
  } catch (error: any) {
    if (error.status === 404) {
      return false;
    }
    throw error;
  }
}