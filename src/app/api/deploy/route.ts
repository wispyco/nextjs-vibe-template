import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server-client';
import { createOctokit } from '@/lib/github';
import { createProjectWithRepo, triggerDeployment } from '@/lib/vercel';
import { getVercelToken } from '@/lib/vercel-tokens';

export const runtime = 'nodejs'; // Use Node.js runtime for SSE

// Helper to send SSE messages
function sendSSE(encoder: TextEncoder, controller: ReadableStreamDefaultController, data: any) {
  const message = `data: ${JSON.stringify(data)}\n\n`;
  controller.enqueue(encoder.encode(message));
}

export async function POST(req: NextRequest) {
  const encoder = new TextEncoder();
  
  // Parse request body first, before creating the stream
  let body;
  try {
    body = await req.json();
  } catch (error) {
    return new Response(
      JSON.stringify({ error: 'Invalid request body' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }
  
  const { projectName, code, appTitle, project } = body;
  
  // Validate required fields
  if (!projectName || (!code && !project)) {
    return new Response(
      JSON.stringify({ error: 'Project name and code/project are required' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }
  
  // Create a readable stream for SSE
  const stream = new ReadableStream({
    async start(controller) {
      try {
        // Get authenticated user
        const supabase = await createClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        
        if (authError || !user) {
          console.error('Auth error in deploy:', authError);
          sendSSE(encoder, controller, {
            stage: 'error',
            message: 'Authentication required',
            error: 'Please sign in to deploy'
          });
          controller.close();
          return;
        }
        
        console.log('Deploying for user:', user.email);

        // Check if user has Vercel token
        const vercelToken = await getVercelToken();
        if (!vercelToken) {
          sendSSE(encoder, controller, {
            stage: 'error',
            message: 'Vercel not connected',
            error: 'Please connect your Vercel account in settings'
          });
          controller.close();
          return;
        }

        // Get user's GitHub username from Supabase
        const { data: profile } = await supabase
          .from('profiles')
          .select('github_username')
          .eq('id', user.id)
          .single();
          
        const githubUsername = profile?.github_username || user.user_metadata?.user_name || user.email?.split('@')[0];
        
        // Update profile with GitHub username if not set
        if (!profile?.github_username && user.user_metadata?.user_name) {
          await supabase
            .from('profiles')
            .upsert({
              id: user.id,
              github_username: user.user_metadata.user_name
            });
        }

        // Check if project already exists in our database
        const { data: existingProject } = await supabase
          .from('projects')
          .select('*')
          .eq('user_id', user.id)
          .eq('name', projectName)
          .single();

        let dbProject = existingProject;
        let isNewProject = !existingProject;

        // Step 1: Create or get GitHub repository
        sendSSE(encoder, controller, {
          stage: 'creating-repo',
          message: existingProject ? 'Checking GitHub repository...' : 'Creating GitHub repository...'
        });

        const octokit = createOctokit();
        
        let repo: any = null;
        try {
          if (existingProject) {
            // Try to get existing repository
            try {
              const repoResponse = await octokit.repos.get({
                owner: existingProject.github_owner,
                repo: existingProject.github_name,
              });
              repo = repoResponse.data;
              sendSSE(encoder, controller, {
                stage: 'creating-repo',
                message: 'Found existing repository'
              });
            } catch (getError) {
              // Repository doesn't exist, create it
              const repoResponse = await octokit.repos.createForAuthenticatedUser({
                name: projectName,
                description: `${appTitle} - Generated by vibeweb.app`,
                private: false,
                auto_init: true,
              });
              repo = repoResponse.data;
            }
          } else {
            // Create new repository
            const repoResponse = await octokit.repos.createForAuthenticatedUser({
              name: projectName,
              description: `${appTitle} - Generated by vibeweb.app`,
              private: false,
              auto_init: true,
            });
            repo = repoResponse.data;
            
            // Wait a moment for GitHub to fully initialize the repository
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        } catch (error: any) {
          if (error.status === 422) {
            // Repository already exists with different owner
            sendSSE(encoder, controller, {
              stage: 'error',
              message: 'Repository name already taken',
              error: 'Please choose a different project name'
            });
          } else {
            sendSSE(encoder, controller, {
              stage: 'error',
              message: 'Failed to access repository',
              error: error.message
            });
          }
          controller.close();
          return;
        }

        // Validate repo object
        if (!repo || !repo.name || !repo.owner || !repo.owner.login) {
          sendSSE(encoder, controller, {
            stage: 'error',
            message: 'Invalid repository data received from GitHub',
            error: 'Repository creation failed'
          });
          controller.close();
          return;
        }

        // Log repo info for debugging
        console.log('Repository created/found:', {
          owner: repo.owner.login,
          name: repo.name,
          full_name: repo.full_name,
        });

        // Step 2: Push code to repository
        sendSSE(encoder, controller, {
          stage: 'pushing-code',
          message: 'Pushing code to repository...'
        });

        try {
          if (project && project.files) {
            // Validate the build before pushing
            sendSSE(encoder, controller, {
              stage: 'validating',
              message: 'Validating Next.js build...'
            });
            
            const { validateSyntax } = await import('@/lib/build-validator');
            const syntaxValidation = validateSyntax(project.files);
            
            if (!syntaxValidation.success) {
              // Try to self-heal the errors
              sendSSE(encoder, controller, {
                stage: 'healing',
                message: 'Build validation failed, attempting to fix errors automatically...'
              });
              
              const { selfHealBuildErrors } = await import('@/lib/ai-agent/self-healer');
              const healResult = await selfHealBuildErrors({
                files: project.files,
                errors: syntaxValidation.errors || [],
              });
              
              if (healResult.success && healResult.fixedFiles) {
                // Update project files with fixes
                project.files = healResult.fixedFiles;
                
                sendSSE(encoder, controller, {
                  stage: 'healing',
                  message: `Fixed ${healResult.changes?.length || 0} files automatically`
                });
                
                // Re-validate after fixes
                const reValidation = validateSyntax(project.files);
                if (!reValidation.success) {
                  sendSSE(encoder, controller, {
                    stage: 'error',
                    message: 'Build still failing after auto-fix attempt',
                    error: reValidation.errors?.join('\n') || 'Syntax errors remain'
                  });
                  controller.close();
                  return;
                }
              } else {
                sendSSE(encoder, controller, {
                  stage: 'error',
                  message: 'Could not automatically fix build errors',
                  error: syntaxValidation.errors?.join('\n') || 'Syntax errors detected'
                });
                controller.close();
                return;
              }
            }
            
            // Push Next.js project files
            const { pushFiles } = await import('@/lib/github');
            
            console.log('Deploying Next.js project with files:', Object.keys(project.files));
            
            sendSSE(encoder, controller, {
              stage: 'pushing-code',
              message: `Pushing ${Object.keys(project.files).length} Next.js files...`
            });

            // Ensure we have valid repo info
            if (!repo.name || !repo.owner?.login) {
              throw new Error(`Invalid repository data: name=${repo.name}, owner=${repo.owner?.login}`);
            }
            
            await pushFiles(
              process.env.GH_PAT!,
              { owner: repo.owner.login, name: repo.name },
              'main',
              project.files,
              `Deploy ${appTitle} - Next.js project`
            );
          } else {
            // Fallback: Push single HTML file
            const { data: existingIndex } = await octokit.repos.getContent({
              owner: repo.owner.login,
              repo: repo.name,
              path: 'index.html',
            }).catch(() => ({ data: null }));

            if (existingIndex && 'sha' in existingIndex) {
              // Update existing index.html
              await octokit.repos.createOrUpdateFileContents({
                owner: repo.owner.login,
                repo: repo.name,
                path: 'index.html',
                message: `Update - ${appTitle}`,
                content: Buffer.from(code).toString('base64'),
                sha: existingIndex.sha,
              });
            } else {
              // Create new index.html
              await octokit.repos.createOrUpdateFileContents({
                owner: repo.owner.login,
                repo: repo.name,
                path: 'index.html',
                message: `Initial commit - ${appTitle}`,
                content: Buffer.from(code).toString('base64'),
              });
            }
          }

          // Create README only for HTML projects (Next.js projects include their own)
          if (!project || !project.files) {
            const readmeContent = `# ${appTitle}

This project was generated by [vibeweb.app](https://vibeweb.app).

## Description

${appTitle} - A web application built with modern web technologies.

## Getting Started

Simply open \`index.html\` in your web browser to view the application.

## Deployment

This project is automatically deployed to Vercel.

---

Generated with ❤️ by vibeweb.app`;

            try {
              // Check if README already exists
              const { data: existingReadme } = await octokit.repos.getContent({
                owner: repo.owner.login,
                repo: repo.name,
                path: 'README.md',
              }).catch(() => ({ data: null }));

              if (existingReadme && 'sha' in existingReadme) {
                // Update existing README
                await octokit.repos.createOrUpdateFileContents({
                  owner: repo.owner.login,
                  repo: repo.name,
                  path: 'README.md',
                  message: 'Update README',
                  content: Buffer.from(readmeContent).toString('base64'),
                  sha: existingReadme.sha,
                });
              } else {
                // Create new README
                await octokit.repos.createOrUpdateFileContents({
                  owner: repo.owner.login,
                  repo: repo.name,
                  path: 'README.md',
                  message: 'Add README',
                  content: Buffer.from(readmeContent).toString('base64'),
                });
              }
            } catch (readmeError) {
              console.warn('Could not create/update README:', readmeError);
              // Continue without README - not critical
            }
          }
        } catch (error: any) {
          sendSSE(encoder, controller, {
            stage: 'error',
            message: 'Failed to push code',
            error: error.message
          });
          controller.close();
          return;
        }

        // Step 3: Create or get Vercel project
        sendSSE(encoder, controller, {
          stage: 'creating-project',
          message: 'Setting up Vercel project...'
        });

        let vercelProject;
        try {
          // First try to get existing project
          const { getProject } = await import('@/lib/vercel');
          try {
            vercelProject = await getProject(projectName);
            sendSSE(encoder, controller, {
              stage: 'creating-project',
              message: 'Found existing Vercel project'
            });
          } catch (getError: any) {
            // Project doesn't exist, create it
            vercelProject = await createProjectWithRepo({
              projectName,
              gitRepoId: repo.id,
              gitRepoOwner: repo.owner.login,
              gitRepoName: repo.name,
              framework: undefined, // Let Vercel auto-detect
              rootDirectory: undefined, // Let Vercel use the default (repository root)
            });
            sendSSE(encoder, controller, {
              stage: 'creating-project',
              message: 'Created new Vercel project'
            });
          }
        } catch (error: any) {
          sendSSE(encoder, controller, {
            stage: 'error',
            message: 'Failed to setup Vercel project',
            error: error.message
          });
          controller.close();
          return;
        }

        // Step 4: Trigger deployment
        sendSSE(encoder, controller, {
          stage: 'deploying',
          message: 'Deploying to Vercel...'
        });

        let deployment;
        try {
          deployment = await triggerDeployment(
            projectName,
            'main',
            repo.id,
            repo.owner.login,
            repo.name
          );
        } catch (error: any) {
          sendSSE(encoder, controller, {
            stage: 'error',
            message: 'Failed to trigger deployment',
            error: error.message
          });
          controller.close();
          return;
        }

        // Step 5: Store project and deployment in database
        sendSSE(encoder, controller, {
          stage: 'saving',
          message: 'Saving deployment information...'
        });

        try {
          // Create or update project record
          if (isNewProject) {
            const { data: newProject, error: projectError } = await supabase
              .from('projects')
              .insert({
                user_id: user.id,
                name: projectName,
                description: appTitle,
                github_repo: `${repo.owner.login}/${repo.name}`,
                github_owner: repo.owner.login,
                github_name: repo.name,
                github_url: repo.html_url,
                vercel_project_id: vercelProject.id,
                vercel_project_name: vercelProject.name,
                is_private: false,
                status: 'deployed',
                last_deployed_at: new Date().toISOString(),
              })
              .select()
              .single();

            if (projectError) {
              console.error('Failed to save project:', projectError);
            } else {
              dbProject = newProject;
            }
          } else {
            // Update existing project
            const { error: updateError } = await supabase
              .from('projects')
              .update({
                vercel_project_id: vercelProject.id,
                vercel_project_name: vercelProject.name,
                status: 'deployed',
                last_deployed_at: new Date().toISOString(),
                updated_at: new Date().toISOString(),
              })
              .eq('id', dbProject.id);

            if (updateError) {
              console.error('Failed to update project:', updateError);
            }
          }

          // Create deployment record
          if (dbProject) {
            const { error: deploymentError } = await supabase
              .from('deployments')
              .insert({
                project_id: dbProject.id,
                user_id: user.id,
                deployment_id: deployment.uid || deployment.id || projectName,
                deployment_url: deployment.url || `${projectName}.vercel.app`,
                status: 'ready',
                environment: 'production',
                source: isNewProject ? 'manual' : 'redeploy',
                metadata: {
                  vercel_deployment: deployment,
                  vercel_project: vercelProject,
                },
                completed_at: new Date().toISOString(),
              });

            if (deploymentError) {
              console.error('Failed to save deployment:', deploymentError);
            }
          }
        } catch (dbError) {
          console.error('Database error:', dbError);
          // Continue even if database save fails
        }

        // Step 6: Complete
        // Construct deployment URL - Vercel uses project-name.vercel.app by default
        const deploymentUrl = deployment.url 
          ? `https://${deployment.url}`
          : `https://${projectName}.vercel.app`;
          
        sendSSE(encoder, controller, {
          stage: 'complete',
          message: 'Deployment complete!',
          data: {
            repoUrl: repo.html_url,
            deploymentUrl: deploymentUrl,
            projectId: dbProject?.id,
            isRedeploy: !isNewProject,
          }
        });

        controller.close();
      } catch (error: any) {
        sendSSE(encoder, controller, {
          stage: 'error',
          message: 'Unexpected error',
          error: error.message
        });
        controller.close();
      }
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}